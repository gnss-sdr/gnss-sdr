

/* this file was generated by volk_gnsssdr template utils, do not edit! */

/*
 * GNSS-SDR is a Global Navigation Satellite System software-defined receiver.
 * This file is part of GNSS-SDR.
 *
 * Copyright (C) 2010-2019 (see AUTHORS file for a list of contributors)
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 */

// clang-format off
#include <volk_gnsssdr/volk_gnsssdr_cpu.h>
#include <volk_gnsssdr/volk_gnsssdr_config_fixed.h>
#include <stdlib.h>
#include <string.h>
// clang-format on

struct VOLK_CPU volk_gnsssdr_cpu;

#if defined(__i386__) || defined(__x86_64__) || defined(_M_IX86) || defined(_M_X64)
#define VOLK_CPU_x86
#endif

#if defined(VOLK_CPU_x86)

// implement get cpuid for gcc compilers using a system or local copy of cpuid.h
#if defined(__GNUC__)
#include <cpuid.h>
#define cpuid_x86(op, r) __get_cpuid(op, (unsigned int *)r + 0, (unsigned int *)r + 1, (unsigned int *)r + 2, (unsigned int *)r + 3)
#define cpuid_x86_count(op, count, regs) __cpuid_count(op, count, *((unsigned int *)regs), *((unsigned int *)regs + 1), *((unsigned int *)regs + 2), *((unsigned int *)regs + 3))

/* Return Intel AVX extended CPU capabilities register.
 * This function will bomb on non-AVX-capable machines, so
 * check for AVX capability before executing.
 */
#if ((__GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 2) || (__clang_major__ >= 3)) && defined(HAVE_XGETBV)
static inline unsigned long long _xgetbv(unsigned int index)
{
    unsigned int eax, edx;
    __VOLK_ASM __VOLK_VOLATILE("xgetbv"
                               : "=a"(eax), "=d"(edx)
                               : "c"(index));
    return ((unsigned long long)edx << 32) | eax;
}
#define __xgetbv() _xgetbv(0)
#else
#define __xgetbv() 0
#endif

// implement get cpuid for MSVC compilers using __cpuid intrinsic
#elif defined(_MSC_VER) && defined(HAVE_INTRIN_H)
#include <intrin.h>
#define cpuid_x86(op, r) __cpuid(((int *)r), op)
#define cpuid_x86_count(op, count, regs) __cpuidex((int *)regs, op, count)

#if defined(_XCR_XFEATURE_ENABLED_MASK)
#define __xgetbv() _xgetbv(_XCR_XFEATURE_ENABLED_MASK)
#else
#define __xgetbv() 0
#endif

#else
#error "A get cpuid for volk_gnsssdr is not available on this compiler..."
#endif  // defined(__GNUC__)

#endif  // defined(VOLK_CPU_x86)

static inline unsigned int cpuid_count_x86_bit(unsigned int level, unsigned int count, unsigned int reg, unsigned int bit)
{
#if defined(VOLK_CPU_x86)
    unsigned int regs[4] = {0};
    cpuid_x86_count(level, count, regs);
    return regs[reg] >> bit & 0x01;
#else
    return 0;
#endif
}

static inline unsigned int cpuid_x86_bit(unsigned int reg, unsigned int op, unsigned int bit)
{
#if defined(VOLK_CPU_x86)
    unsigned int regs[4];
    memset(regs, 0, sizeof(unsigned int) * 4);
    cpuid_x86(op, regs);
    return regs[reg] >> bit & 0x01;
#else
    return 0;
#endif
}

static inline unsigned int check_extended_cpuid(unsigned int val)
{
#if defined(VOLK_CPU_x86)
    unsigned int regs[4];
    memset(regs, 0, sizeof(unsigned int) * 4);
    cpuid_x86(0x80000000, regs);
    return regs[0] >= val;
#else
    return 0;
#endif
}

static inline unsigned int get_avx_enabled(void)
{
#if defined(VOLK_CPU_x86)
    return __xgetbv() & 0x6;
#else
    return 0;
#endif
}

static inline unsigned int get_avx2_enabled(void)
{
#if defined(VOLK_CPU_x86)
    return __xgetbv() & 0x6;
#else
    return 0;
#endif
}

static inline unsigned int get_avx512_enabled(void)
{
#if defined(VOLK_CPU_x86)
    return __xgetbv() & 0xE6;  // check for zmm, xmm and ymm regs
#else
    return 0;
#endif
}

// neon detection is linux specific
#if defined(__arm__) && defined(__linux__)
#include <asm/hwcap.h>
#include <linux/auxvec.h>
#include <stdio.h>
#define VOLK_CPU_ARMV7
#endif

static int has_neonv7(void)
{
#if defined(VOLK_CPU_ARMV7)
    FILE *auxvec_f;
    unsigned long auxvec[2];
    unsigned int found_neon = 0;
    auxvec_f = fopen("/proc/self/auxv", "rb");
    if (!auxvec_f) return 0;

    size_t r = 1;
    // so auxv is basically 32b of ID and 32b of value
    // so it goes like this
    while (!found_neon && r)
        {
            r = fread(auxvec, sizeof(unsigned long), 2, auxvec_f);
            if ((auxvec[0] == AT_HWCAP) && (auxvec[1] & HWCAP_NEON))
                found_neon = 1;
        }

    fclose(auxvec_f);
    return found_neon;
#else
    return 0;
#endif
}

//\todo: Fix this to really check for neon on aarch64
// neon detection is linux specific
#if defined(__aarch64__) && defined(__linux__)
#include <asm/hwcap.h>
#include <linux/auxvec.h>
#include <stdio.h>
#define VOLK_CPU_ARMV8
#endif

static int has_neonv8(void)
{
#if defined(VOLK_CPU_ARMV8)
    FILE *auxvec_f;
    unsigned long auxvec[2];
    unsigned int found_neon = 0;
    auxvec_f = fopen("/proc/self/auxv", "rb");
    if (!auxvec_f) return 0;

    size_t r = 1;
    // so auxv is basically 32b of ID and 32b of value
    // so it goes like this
    while (!found_neon && r)
        {
            r = fread(auxvec, sizeof(unsigned long), 2, auxvec_f);
            if ((auxvec[0] == AT_HWCAP) && (auxvec[1] & HWCAP_ASIMD))
                found_neon = 1;
        }

    fclose(auxvec_f);
    return found_neon;
#else
    return 0;
#endif
}

static int has_neon(void)
{
#if defined(VOLK_CPU_ARMV8) || defined(VOLK_CPU_ARMV7)
    if (has_neonv7() || has_neonv8())
        return 1;
    else
        return 0;
#else
    return 0;
#endif
}
// clang-format off

static int i_can_has_generic (void) {
    return 1;
}
static int i_can_has_softfp (void) {
    return 1;
}
static int i_can_has_hardfp (void) {
    return 1;
}
static int i_can_has_neon (void) {
    if (has_neon() == 0) return 0;
    return 1;
}
static int i_can_has_neonv7 (void) {
    if (has_neonv7() == 0) return 0;
    return 1;
}
static int i_can_has_neonv8 (void) {
    if (has_neonv8() == 0) return 0;
    return 1;
}
static int i_can_has_32 (void) {
    return 1;
}
static int i_can_has_64 (void) {
    if (check_extended_cpuid(0x80000001) == 0) return 0;
    if (cpuid_x86_bit(3, 0x80000001, 29) == 0) return 0;
    return 1;
}
static int i_can_has_3dnow (void) {
    if (cpuid_x86_bit(3, 0x80000001, 31) == 0) return 0;
    return 1;
}
static int i_can_has_abm (void) {
    if (cpuid_x86_bit(3, 0x80000001, 5) == 0) return 0;
    return 1;
}
static int i_can_has_popcount (void) {
    if (cpuid_x86_bit(2, 0x00000001, 23) == 0) return 0;
    return 1;
}
static int i_can_has_mmx (void) {
    if (cpuid_x86_bit(3, 0x00000001, 23) == 0) return 0;
    return 1;
}
static int i_can_has_fma (void) {
    if (cpuid_x86_bit(2, 0x00000001, 12) == 0) return 0;
    return 1;
}
static int i_can_has_sse (void) {
    if (cpuid_x86_bit(3, 0x00000001, 25) == 0) return 0;
    return 1;
}
static int i_can_has_sse2 (void) {
    if (cpuid_x86_bit(3, 0x00000001, 26) == 0) return 0;
    return 1;
}
static int i_can_has_orc (void) {
    return 1;
}
static int i_can_has_norc (void) {
    return 1;
}
static int i_can_has_sse3 (void) {
    if (cpuid_x86_bit(2, 0x00000001, 0) == 0) return 0;
    return 1;
}
static int i_can_has_ssse3 (void) {
    if (cpuid_x86_bit(2, 0x00000001, 9) == 0) return 0;
    return 1;
}
static int i_can_has_sse4_a (void) {
    if (cpuid_x86_bit(2, 0x80000001, 6) == 0) return 0;
    return 1;
}
static int i_can_has_sse4_1 (void) {
    if (cpuid_x86_bit(2, 0x00000001, 19) == 0) return 0;
    return 1;
}
static int i_can_has_sse4_2 (void) {
    if (cpuid_x86_bit(2, 0x00000001, 20) == 0) return 0;
    return 1;
}
static int i_can_has_avx (void) {
    if (cpuid_x86_bit(2, 0x00000001, 28) == 0) return 0;
    if (cpuid_x86_bit(2, 0x00000001, 27) == 0) return 0;
    if (get_avx_enabled() == 0) return 0;
    return 1;
}
static int i_can_has_avx2 (void) {
    if (cpuid_count_x86_bit(7, 0, 1, 5) == 0) return 0;
    if (cpuid_x86_bit(2, 0x00000001, 27) == 0) return 0;
    if (get_avx2_enabled() == 0) return 0;
    return 1;
}
static int i_can_has_avx512f (void) {
    if (cpuid_count_x86_bit(7, 0, 1, 16) == 0) return 0;
    if (cpuid_x86_bit(2, 0x00000001, 27) == 0) return 0;
    if (get_avx512_enabled() == 0) return 0;
    return 1;
}
static int i_can_has_avx512cd (void) {
    if (cpuid_count_x86_bit(7, 0, 1, 28) == 0) return 0;
    if (cpuid_x86_bit(2, 0x00000001, 27) == 0) return 0;
    if (get_avx512_enabled() == 0) return 0;
    return 1;
}

#if defined(HAVE_FENV_H)
    #if defined(FE_TONEAREST)
        #include <fenv.h>
        static inline void set_float_rounding(void){
            fesetround(FE_TONEAREST);
        }
    #else
        static inline void set_float_rounding(void){
            // do nothing
        }
    #endif
#elif defined(_MSC_VER)
    #include <float.h>
    static inline void set_float_rounding(void){
        unsigned int cwrd;
        _controlfp_s(&cwrd, 0, 0);
        _controlfp_s(&cwrd, _RC_NEAR, _MCW_RC);
    }
#else
    static inline void set_float_rounding(void){
        // do nothing
    }
#endif

void volk_gnsssdr_cpu_init() {
    volk_gnsssdr_cpu.has_generic = &i_can_has_generic;
    volk_gnsssdr_cpu.has_softfp = &i_can_has_softfp;
    volk_gnsssdr_cpu.has_hardfp = &i_can_has_hardfp;
    volk_gnsssdr_cpu.has_neon = &i_can_has_neon;
    volk_gnsssdr_cpu.has_neonv7 = &i_can_has_neonv7;
    volk_gnsssdr_cpu.has_neonv8 = &i_can_has_neonv8;
    volk_gnsssdr_cpu.has_32 = &i_can_has_32;
    volk_gnsssdr_cpu.has_64 = &i_can_has_64;
    volk_gnsssdr_cpu.has_3dnow = &i_can_has_3dnow;
    volk_gnsssdr_cpu.has_abm = &i_can_has_abm;
    volk_gnsssdr_cpu.has_popcount = &i_can_has_popcount;
    volk_gnsssdr_cpu.has_mmx = &i_can_has_mmx;
    volk_gnsssdr_cpu.has_fma = &i_can_has_fma;
    volk_gnsssdr_cpu.has_sse = &i_can_has_sse;
    volk_gnsssdr_cpu.has_sse2 = &i_can_has_sse2;
    volk_gnsssdr_cpu.has_orc = &i_can_has_orc;
    volk_gnsssdr_cpu.has_norc = &i_can_has_norc;
    volk_gnsssdr_cpu.has_sse3 = &i_can_has_sse3;
    volk_gnsssdr_cpu.has_ssse3 = &i_can_has_ssse3;
    volk_gnsssdr_cpu.has_sse4_a = &i_can_has_sse4_a;
    volk_gnsssdr_cpu.has_sse4_1 = &i_can_has_sse4_1;
    volk_gnsssdr_cpu.has_sse4_2 = &i_can_has_sse4_2;
    volk_gnsssdr_cpu.has_avx = &i_can_has_avx;
    volk_gnsssdr_cpu.has_avx2 = &i_can_has_avx2;
    volk_gnsssdr_cpu.has_avx512f = &i_can_has_avx512f;
    volk_gnsssdr_cpu.has_avx512cd = &i_can_has_avx512cd;
    set_float_rounding();
}

unsigned int volk_gnsssdr_get_lvarch() {
    unsigned int retval = 0;
    volk_gnsssdr_cpu_init();
    retval += volk_gnsssdr_cpu.has_generic() << LV_GENERIC;
    retval += volk_gnsssdr_cpu.has_softfp() << LV_SOFTFP;
    retval += volk_gnsssdr_cpu.has_hardfp() << LV_HARDFP;
    retval += volk_gnsssdr_cpu.has_neon() << LV_NEON;
    retval += volk_gnsssdr_cpu.has_neonv7() << LV_NEONV7;
    retval += volk_gnsssdr_cpu.has_neonv8() << LV_NEONV8;
    retval += volk_gnsssdr_cpu.has_32() << LV_32;
    retval += volk_gnsssdr_cpu.has_64() << LV_64;
    retval += volk_gnsssdr_cpu.has_3dnow() << LV_3DNOW;
    retval += volk_gnsssdr_cpu.has_abm() << LV_ABM;
    retval += volk_gnsssdr_cpu.has_popcount() << LV_POPCOUNT;
    retval += volk_gnsssdr_cpu.has_mmx() << LV_MMX;
    retval += volk_gnsssdr_cpu.has_fma() << LV_FMA;
    retval += volk_gnsssdr_cpu.has_sse() << LV_SSE;
    retval += volk_gnsssdr_cpu.has_sse2() << LV_SSE2;
    retval += volk_gnsssdr_cpu.has_orc() << LV_ORC;
    retval += volk_gnsssdr_cpu.has_norc() << LV_NORC;
    retval += volk_gnsssdr_cpu.has_sse3() << LV_SSE3;
    retval += volk_gnsssdr_cpu.has_ssse3() << LV_SSSE3;
    retval += volk_gnsssdr_cpu.has_sse4_a() << LV_SSE4_A;
    retval += volk_gnsssdr_cpu.has_sse4_1() << LV_SSE4_1;
    retval += volk_gnsssdr_cpu.has_sse4_2() << LV_SSE4_2;
    retval += volk_gnsssdr_cpu.has_avx() << LV_AVX;
    retval += volk_gnsssdr_cpu.has_avx2() << LV_AVX2;
    retval += volk_gnsssdr_cpu.has_avx512f() << LV_AVX512F;
    retval += volk_gnsssdr_cpu.has_avx512cd() << LV_AVX512CD;
    return retval;
}
// clang-format on
