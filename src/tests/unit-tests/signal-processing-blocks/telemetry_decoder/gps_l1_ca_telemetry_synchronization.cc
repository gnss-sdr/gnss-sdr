/*!
 * \file gps_l1_ca_telemetry_decoder_lucas_test.cc
 * \brief  This class implements a telemetry decoder test for GPS_L1_CA_Telemetry_Decoder
 *  implementation based on some input parameters.
 * \author Lucas Ventura, 2015. lucas.ventura.r(at)gmail.com
 *
 *
 * -------------------------------------------------------------------------
 *
 * Copyright (C) 2012-2018  (see AUTHORS file for a list of contributors)
 *
 * GNSS-SDR is a software defined Global Navigation
 *          Satellite Systems receiver
 *
 * This file is part of GNSS-SDR.
 *
 * GNSS-SDR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GNSS-SDR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNSS-SDR. If not, see <https://www.gnu.org/licenses/>.
 *
 * -------------------------------------------------------------------------
 */

#include <chrono>
#include "gnss_synchro.h"
#include <gtest/gtest.h>
#include <random>

#define vector_size 6000 		// 20 sub-frames with 300 bits
#define preamble_offset 200		// Random data before preamble


class GpsL1CATelemetrySynchronizationTest : public ::testing::Test
{
public:
	std::vector<int> initial_vector;
	std::vector<double> synchro_vector;
	
	void preamble_samples();
	void make_vector();
	void fill_gnss_synchro();
	
	// gps_l1_ca_telemetry_decoder_gs.h
	int32_t d_bits_per_preamble = GPS_CA_PREAMBLE_LENGTH_BITS;
	int32_t d_samples_per_preamble = d_bits_per_preamble;
	int32_t d_preamble_period_symbols = GPS_SUBFRAME_BITS;
	
	// set the preamble
	uint32_t d_required_symbols = GPS_SUBFRAME_BITS;
	// preamble bits to sampled symbols
	uint32_t d_frame_length_symbols = GPS_SUBFRAME_BITS * GPS_CA_TELEMETRY_SYMBOLS_PER_BIT;
		
	std::array<int32_t, GPS_CA_PREAMBLE_LENGTH_BITS> d_preamble_samples{};
	
	bool flag_PLL_180_deg_phase_locked;
	
	boost::circular_buffer<float> d_symbol_history;

	uint64_t d_sample_counter = 0ULL;
	uint64_t d_preamble_index = 0ULL;
	
	uint32_t d_stat = 0;

};


void GpsL1CATelemetrySynchronizationTest::preamble_samples()
{
	int32_t n = 0;
	
	for (int32_t i = 0; i < d_bits_per_preamble; i++)
		{
			if (GPS_CA_PREAMBLE.at(i) == '1')
				{
					d_preamble_samples[n] = 1;
					n++;
				}
			else
				{
					d_preamble_samples[n] = -1;
					n++;
				}
		}
	
	
	d_symbol_history.set_capacity(d_required_symbols);
}


/*!
 * \ Vector with preambles and random data
 *
 * The first preamble starts in "preamble_offset".
 * Preamble every "d_preamble_period_symbols" (300).
 * The Synchronization Word is "10001011".
 */
void GpsL1CATelemetrySynchronizationTest::make_vector()
{
	std::random_device rd;  //Otain a seed for the random number engine
	std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
	std::uniform_int_distribution<> dis(0, 1);
	 
	
	for (int32_t i = 0; i < vector_size; i++)
	{
    	if((i - preamble_offset) % d_preamble_period_symbols == 0)
            initial_vector.push_back(1);
    	else if((i - 1 - preamble_offset) % d_preamble_period_symbols == 0)
            initial_vector.push_back(-1);
    	else if((i - 2 - preamble_offset) % d_preamble_period_symbols == 0)
    		initial_vector.push_back(-1);
    	else if((i - 3 - preamble_offset) % d_preamble_period_symbols == 0)
    	    initial_vector.push_back(-1);
    	else if((i - 4 - preamble_offset) % d_preamble_period_symbols == 0)
    		initial_vector.push_back(1);
    	else if((i - 5 - preamble_offset) % d_preamble_period_symbols == 0)
    		initial_vector.push_back(-1);
    	else if((i - 6 - preamble_offset) % d_preamble_period_symbols == 0)
    		initial_vector.push_back(1);
    	else if((i - 7 - preamble_offset) % d_preamble_period_symbols == 0)
    		initial_vector.push_back(1);
    	else
    		initial_vector.push_back(dis(gen)*2-1); //Transform the random unsigned int generated by gen into an int in [-1, 1]
	}
}


/*!
 * \ Simulates Prompt_I in the gnss_synchro vector
 *
 * Adds noise with a mean and standard deviation to the initial_vector
 */
void GpsL1CATelemetrySynchronizationTest::fill_gnss_synchro()
{
    // Random generator with Gaussian distribution
    const double mean = 0.0;
    const double stddev = 0.0;
    auto dist = std::bind(std::normal_distribution<double>{mean, stddev},
                          std::mt19937(std::random_device{}()));
	
    for (int32_t i = 0; i < vector_size; i++)
    {
    	synchro_vector.push_back(initial_vector[i] + dist());
    }   
	
}

/*
// TEST check
TEST_F(GpsL1CATelemetrySynchronizationTest, Check)
{
	std::chrono::time_point<std::chrono::system_clock> start, end;
	std::chrono::duration<double> elapsed_seconds(0);
	start = std::chrono::system_clock::now();
	
	preamble_samples();
	make_vector();
	fill_gnss_synchro();
	
	for (int32_t i = 0; i < vector_size; i++)
	{
		std::cout << i << "\t\t" << initial_vector[i] << std::endl;
	}
	
	
    end = std::chrono::system_clock::now();
    elapsed_seconds = end - start;
    std::cout << "GPSL1CA Telemetry decoder Test completed in " << elapsed_seconds.count() * 1e6 << " microseconds" << std::endl;
	
}
*/

// TEST ValidationOfResults
TEST_F(GpsL1CATelemetrySynchronizationTest, ValidationOfResults)
{
    std::chrono::time_point<std::chrono::system_clock> start, end;
    std::chrono::duration<double> elapsed_seconds(0);
    start = std::chrono::system_clock::now();
	
    preamble_samples();
    make_vector();
    fill_gnss_synchro();
    
    int32_t n_preamble_detections_s0 = 0; 	// Number of detected preambles in state 0
    int32_t n_preamble_detections_s1 = 0; 	// Number of detected preambles in state 1
    int32_t n_correct_detections_s0 = 0;	// Number of correct detected preambles in state 0
    int32_t n_wrong_detections_s0 = 0;		// Number of wrong detected preambles in state 0
    int32_t n_correct_detections_s1 = 0;	// Number of correct detected preambles in state 1
    int32_t n_wrong_detections_s1 = 0;		// Number of wrong detected preambles in state 1
    int32_t n_preambles = 0;				// Number of total preambles (missed and detected)

    
    for (int32_t i = 0; i < vector_size; i++) 
    {    	
    	d_symbol_history.push_back(synchro_vector[i]);
    	d_sample_counter++;
    	    	    	
    	// ******* frame sync ******************
		switch (d_stat)
		{
			case 0:  // no preamble information
			{
				// correlate with preamble
				int32_t corr_value = 0;
				if (d_symbol_history.size() >= GPS_CA_PREAMBLE_LENGTH_BITS)
					{
						// ******* preamble correlation ********
						for (int32_t i = 0; i < GPS_CA_PREAMBLE_LENGTH_BITS; i++)
							{
								if (d_symbol_history[i] < 0.0)  // symbols clipping
									{
										corr_value -= d_preamble_samples[i];
									}
								else
									{
										corr_value += d_preamble_samples[i];
									}
							}
					}
		    	
				 if (abs(corr_value) >= d_samples_per_preamble)
					{
						d_preamble_index = d_sample_counter;  // record the preamble sample stamp
						std::cout << "Preamble detection for GPS L1 satellite " << d_preamble_index << std::endl;
						
						if((d_preamble_index - preamble_offset) % d_preamble_period_symbols == 0)
							n_correct_detections_s0++;
						else
							n_wrong_detections_s0++;
						
						n_preamble_detections_s0++;
																		
						//decode_subframe();
						d_stat = 1;  // enter into frame pre-detection status
					}
				
				break;
			}
			case 1:  // possible preamble lock
			{
				// correlate with preamble
				int32_t corr_value = 0;
				int32_t preamble_diff = 0;
				if (d_symbol_history.size() >= GPS_CA_PREAMBLE_LENGTH_BITS)
					{
						// ******* preamble correlation ********
						for (int32_t i = 0; i < GPS_CA_PREAMBLE_LENGTH_BITS; i++)
							{
								if (d_symbol_history[i] < 0.0)  // symbols clipping
									{
										corr_value -= d_preamble_samples[i];
									}
								else
									{
										corr_value += d_preamble_samples[i];
									}
							}
					}
				if (abs(corr_value) >= d_samples_per_preamble)
					{
						if((d_sample_counter - preamble_offset) % d_preamble_period_symbols == 0)
							n_correct_detections_s1++;
						else
							n_wrong_detections_s1++;
						
						n_preamble_detections_s1++;
						
						// check preamble separation
						preamble_diff = static_cast<int32_t>(d_sample_counter - d_preamble_index);						
						if (abs(preamble_diff - d_preamble_period_symbols) == 0)
							{
								d_preamble_index = d_sample_counter;  // record the preamble sample stamp
								std::cout << "Preamble confirmation " << d_preamble_index << std::endl;
								
								n_preambles = (d_preamble_index - preamble_offset) / d_preamble_period_symbols + 1;
																
								if (corr_value < 0)
									{
										flag_PLL_180_deg_phase_locked = true;
									}
								else
									{
										flag_PLL_180_deg_phase_locked = false;
									}
								// decode_subframe();
								d_stat = 2;
							}
						else
							{
								if (preamble_diff > d_preamble_period_symbols)
									{
										// std::cout << "Preamble missed in s1 " << d_sample_counter << std::endl;
										d_stat = 0;  // start again
									}
							}
					}
				
				break;
			}
			
			case 2: // preamble acquired
			{
				 if (d_sample_counter >= d_preamble_index + static_cast<uint64_t>(d_preamble_period_symbols))
					{
					 	 std::cout << "Preamble received. "  << "d_sample_counter= " << d_sample_counter << std::endl;
					 	 // call the decoder
					 	 // 0. fetch the symbols into an array
					 	 d_preamble_index = d_sample_counter;  // record the preamble sample stamp (t_P)
					}
				
				break;
			}
		}
    }
    
    std::cout << std::endl;
    std::cout << "n_preambles " << n_preambles << std::endl;
    std::cout << std::endl;
    std::cout << "n_preamble_detections_s0 " << n_preamble_detections_s0 << std::endl;
    std::cout << "n_correct_detections_s0 " << n_correct_detections_s0 << std::endl;
    std::cout << "n_wrong_detections_s0 " << n_wrong_detections_s0 << std::endl;
    std::cout << std::endl;
    std::cout << "n_preamble_detections_s1 " << n_preamble_detections_s1 << std::endl;
    std::cout << "n_correct_detections_s1 " << n_correct_detections_s1 << std::endl;
    std::cout << "n_wrong_detections_s1 " << n_wrong_detections_s1 << std::endl;
    std::cout << std::endl;
	
    
    
    end = std::chrono::system_clock::now();
    elapsed_seconds = end - start;
    std::cout << "GPSL1CA Telemetry decoder Test completed in " << elapsed_seconds.count() * 1e6 << " microseconds" << std::endl;
}

